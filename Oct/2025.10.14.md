# TIL

## 날짜: 2025-10-14

### 리펙토링 1일차 : 새로 배운 내용

## 개요: Multipart vs 일반 요청 & Bean Validation 제약

회원가입 API에서 프로필 이미지 업로드 구현 중 `@RequestPart`로 받을 때 Bean Validation이 작동하지 않는 문제를 발견했다. 이 문제를 해결하는 과정에서 Multipart 요청의 구조적 특성과 Spring의 바인딩 메커니즘 차이를 학습했고, 실무에서 파일 업로드를 어떻게 처리하는지 3가지 패턴(Multipart, 분리형, Presigned URL)을 비교 분석했다.

**핵심 질문:**
- 왜 `@RequestBody`는 Bean Validation이 되는데 `@RequestPart`는 안 되는가?
- `@ModelAttribute`로 어떻게 해결할 수 있는가?
- 프론트엔드가 S3에 직접 접근하지 않으려면 어떤 아키텍처를 선택해야 하는가?

---

## 1. Content-Type 차이점

**일반 요청 (JSON)**

```http
POST /users/login HTTP/1.1
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "Test1234!"
}
```

특징:
- 단일 Content-Type
- 모든 데이터가 JSON으로 직렬화
- Spring이 @RequestBody로 자동 역직렬화
- DTO 객체로 즉시 변환 가능

**Multipart 요청**

```http
POST /users/signup HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="email"

test@example.com
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="password"

Test1234!
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="profile_image"; filename="photo.jpg"
Content-Type: image/jpeg

(바이너리 데이터)
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

특징:
- 여러 Part로 분리된 요청
- 각 Part마다 별도의 Content-Disposition
- 파일(바이너리)와 텍스트를 동시에 전송 가능
- Spring이 각 Part를 개별적으로 파싱

**핵심 차이**

| 항목 | JSON | Multipart |
|------|------|-----------|
| Content-Type | application/json | multipart/form-data |
| 데이터 구조 | 단일 JSON 객체 | 여러 Part의 집합 |
| 파일 전송 | 불가능 (Base64 인코딩 필요) | 직접 바이너리 전송 |
| Spring 바인딩 | @RequestBody → DTO | @RequestPart → 개별 필드 |

<br/>
<br/>

## 2. Multipart에서 Bean Validation이 안 되는 이유

**@RequestBody는 작동함**

```java
@PostMapping("/login")
public ResponseEntity<...> login(@Valid @RequestBody LoginRequest request) {
    // ✅ Bean Validation 작동
    // Spring이 JSON → DTO 변환 → @Valid 검증 → Controller 진입
}
```

과정:
1. HttpMessageConverter가 JSON → LoginRequest 변환
2. @Valid가 DTO 필드의 @NotBlank, @Email 검증
3. 실패 시 MethodArgumentNotValidException 발생

**@RequestPart는 작동 안 함**

```java
// ❌ Bean Validation 작동 안 함
@PostMapping("/signup")
public ResponseEntity<...> signup(
    @RequestPart("email") String email,
    @RequestPart("password") String password,
    @RequestPart("nickname") String nickname) {
    // Spring이 각 Part를 String으로만 바인딩
    // DTO 객체를 거치지 않으므로 Bean Validation 실행 안 됨
}
```

이유:
1. 개별 필드로 받음 → DTO 객체 생성 안 됨
2. DTO 없으면 @Valid를 적용할 대상이 없음
3. Spring은 String email에 대해 검증 규칙을 모름

**기술적 원인**

@RequestBody의 경우:
```java
// Spring 내부 처리
1. RequestResponseBodyMethodProcessor 실행
2. HttpMessageConverter가 JSON → DTO 변환
3. DataBinder가 @Valid 검증 수행 ← Bean Validation 작동
4. Controller 메서드 호출
```

@RequestPart의 경우:
```java
// Spring 내부 처리
1. RequestPartMethodArgumentResolver 실행
2. MultipartFile 또는 String으로 직접 추출
3. DTO 변환 없음 ← Bean Validation 적용 불가
4. Controller 메서드 호출
```
<br/>
<br/>

## 3. 핵심 Insight

**Multipart의 설계 목적**
- HTTP 1.0 시대에 파일 업로드를 위해 설계됨
- 각 Part가 독립적 (파일은 바이너리, 텍스트는 문자열)
- DTO 개념이 없던 시절의 프로토콜

**Spring의 제약**
- @RequestPart는 Part 단위 파싱만 담당
- DTO 조립은 개발자 책임 (수동 또는 @ModelAttribute)
- Bean Validation은 DTO 객체가 있어야만 작동

**프로젝트 적용 사례**

| 항목 | @RequestBody (JSON) | @ModelAttribute (Multipart) |
|------|---------------------|----------------------------|
| Content-Type | application/json | multipart/form-data |
| 바인딩 방식 | Jackson ObjectMapper | Form field → Setter 호출 |
| 적합한 사용처 | 일반 REST API | 파일 업로드 포함 요청 |
| Bean Validation | ✅ 지원 | ✅ 지원 |

**현재 프로젝트 상황**

✅ @ModelAttribute 적용 (올바름):
- POST /users/signup - 프로필 이미지 포함 회원가입
- PATCH /users/{userId} - 프로필 이미지 포함 수정

✅ @RequestBody 유지 (올바름):
- POST /auth/login - JSON (email, password)
- POST /posts - JSON (title, content, image_id)
- POST /posts/{postId}/comments - JSON (comment)
- PATCH /users/{userId}/password - JSON (new_password)
- 기타 모든 JSON 엔드포인트

**프로젝트 적용 원칙**
- 파일 업로드 있음 → @ModelAttribute + multipart/form-data
- 파일 없음 → @RequestBody + application/json
<br/>
<br/>
<br/>

## 4. 파일 업로드 아키텍처 선택: 왜 Multipart를 선택했는가?

**3가지 파일 업로드 패턴**

**패턴 1: Multipart (현재 프로젝트 방식)**

프론트엔드:
```javascript
const formData = new FormData();
formData.append('email', email);
formData.append('profile_image', file);
fetch('/users/signup', { method: 'POST', body: formData });
```

백엔드:
```java
@PostMapping("/signup")
public ResponseEntity<?> signup(@ModelAttribute SignupRequest request) {
    String imageUrl = s3Service.upload(request.getProfileImage());
    User user = userService.create(request, imageUrl);
    return ResponseEntity.ok(user);
}
```

장점:
- 1번의 API 호출로 완결
- 구현 간단, 트랜잭션 관리 용이
- 프론트엔드가 S3에 직접 접근하지 않음 (보안)

단점:
- JSON API와 일관성 없음
- 파일 재사용 불가

---

**패턴 2: 분리형 업로드 (백엔드 경유)**

프론트엔드:
```javascript
// Step 1: 파일 업로드
const fileData = new FormData();
fileData.append('file', file);
const { file_id } = await fetch('/files/upload', {
  method: 'POST',
  body: fileData
}).then(r => r.json());

// Step 2: JSON으로 회원가입
await fetch('/users/signup', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, profile_image_id: file_id })
});
```

백엔드:
```java
@PostMapping("/files/upload")
public FileResponse upload(@RequestParam MultipartFile file) {
    String url = s3Service.upload(file);
    return new FileResponse(fileId, url);
}

@PostMapping("/signup")
public ResponseEntity<?> signup(@RequestBody SignupRequest request) {
    User user = userService.create(request);
    return ResponseEntity.ok(user);
}
```

장점:
- 모든 API가 JSON으로 통일
- 파일 재사용 가능
- 업로드 진행률 표시 가능
- 프론트엔드가 S3에 직접 접근하지 않음 (보안)

단점:
- API 호출 2번 필요
- 트랜잭션 관리 복잡 (파일 업로드 성공 but 회원가입 실패 시)

---

**패턴 3: Presigned URL (프론트 직접 S3 업로드)**

프론트엔드:
```javascript
// Step 1: 업로드 URL 요청
const { upload_url, file_id } = await fetch('/files/presigned-url')
  .then(r => r.json());

// Step 2: 프론트가 S3에 직접 업로드
await fetch(upload_url, {
  method: 'PUT',
  body: file
});

// Step 3: 회원가입
await fetch('/users/signup', {
  method: 'POST',
  body: JSON.stringify({ email, profile_image_id: file_id })
});
```

백엔드:
```java
@GetMapping("/files/presigned-url")
public PresignedUrlResponse getPresignedUrl(@RequestParam String filename) {
    String uploadUrl = s3Service.generatePresignedUrl(filename);
    return new PresignedUrlResponse(uploadUrl, fileId);
}
```

장점:
- 서버 부하 최소화 (파일이 백엔드를 거치지 않음)
- 대용량 파일 처리 가능
- 속도 빠름

단점:
- 프론트엔드 복잡도 증가 (S3 직접 접근)
- S3 CORS 설정 필수
- AWS SDK 의존성 추가 가능성

---

**패턴 비교표**

| 기준 | Multipart | 분리형 | Presigned URL |
|------|-----------|--------|---------------|
| API 호출 횟수 | 1번 | 2번 | 3번 |
| 프론트 S3 접근 | ❌ | ❌ | ⚠️ 직접 접근 |
| 구현 복잡도 | 낮음 | 중간 | 높음 |
| API 일관성 | JSON과 혼재 | 모두 JSON | 모두 JSON |
| 파일 재사용 | 불가 | 가능 | 가능 |
| 서버 부하 | 중간 | 중간 | 최소 |
| 적합한 규모 | 소규모 | 중대규모 | 대규모 |

---

**현재 프로젝트의 선택: Multipart**

**의사결정 과정:**
```
질문 1: "프론트엔드가 S3에 직접 접근해야 하는가?"
      ↓ NO
이유: - AWS 인증 정보 노출 방지
     - 프론트엔드 복잡도 감소
     - S3 CORS 설정 불필요
      ↓
Presigned URL 패턴 제외 ✅

질문 2: "Multipart vs 분리형?"
      ↓ Multipart 선택
이유: - 학습 프로젝트 (빠른 구현)
     - 프로필 이미지 재사용 불필요
     - 파일과 회원정보가 강하게 결합
     - 트랜잭션 관리 단순
```

**트레이드오프 인식:**
- 선택한 것: 구현 간단성, 트랜잭션 일관성
- 포기한 것: API 일관성, 파일 재사용성

**확장 계획:**
향후 다음 요구사항이 발생하면 분리형으로 리팩토링:
- 여러 엔티티에서 같은 파일 참조 필요
- 대용량 파일 업로드 (진행률 표시)
- 파일 미리보기 기능

