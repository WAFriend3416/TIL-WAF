# TIL

## 날짜: 2025-10-17

### 개요: Anemic vs. Rich Domain Model

Spring 프로젝트 리팩토링 중 `Post` Entity가 데이터만 담고 있고 비즈니스 로직이 모두 `PostService`에 집중된 구조를 발견했다. 이것이 Anemic Domain Model 안티패턴인지 검토했고, 현재 프로젝트에서는 Transaction Script 패턴으로서 의도된 설계임을 확인했다. Rich Domain Model과의 차이, 각 패턴의 적용 시점을 학습했다.

**핵심 질문:**
- Anemic과 Rich Domain Model의 근본적 차이는 무엇인가?
- Service에 비즈니스 로직이 집중되는 것은 언제 문제가 되는가?
- 현재 프로젝트에 Rich Domain Model이 필요한가?

---

### 1. 개념 정의

**Anemic Domain Model (빈약한 도메인 모델)**
- Entity가 데이터 컨테이너 역할만 수행 (Getter/Setter 위주)
- 비즈니스 로직이 Service Layer에 집중
- 외부(Service)에서 Entity의 상태를 변경
- Transaction Script 패턴과 유사

**Rich Domain Model (풍부한 도메인 모델)**
- Entity가 비즈니스 로직과 데이터를 함께 캡슐화 (능동적)
- 비즈니스 로직이 Entity 내부에 집중
- Entity가 스스로 상태와 규칙(불변식)을 보호
- DDD(Domain-Driven Design) 패턴과 부합

**비교표**

| 항목 | Anemic Domain Model | Rich Domain Model |
|------|-------------------|-------------------|
| Entity 역할 | 데이터 컨테이너 | 로직 + 데이터 캡슐화 |
| 비즈니스 로직 | Service Layer | Entity 내부 |
| 상태 관리 | 외부(Service)에서 변경 | Entity가 자체 보호 |
| 패턴 | Transaction Script | DDD |

---

<br/>
<br/>

### 2. 현재 프로젝트 상태: Anemic Domain Model

**증거**

`Post` Entity는 데이터 필드와 단순 `update` 메서드만 보유. 게시글 생성/수정/삭제와 관련된 모든 비즈니스 규칙(사용자 검증, 통계 초기화, 이미지 연결 등)이 `PostService`에 집중되어 있음.

**초기 문제 인식**
- Entity가 제목 길이 제한, 상태 변경 규칙 같은 자체 규칙을 보호하지 못함
- 권한 검증 등 유사한 로직이 여러 Service 메서드에서 중복될 가능성 존재
- 도메인 로직이 Service에 흩어져 응집도가 낮고 재사용성이 떨어짐

**Rich Domain Model 리팩토링 안**

Entity 개선 예시:
```java
public class Post {
    // 기존 필드

    public static Post create(User author, String title, String content) {
        validateTitle(title);
        Post post = new Post();
        post.author = author;
        post.title = title;
        post.content = content;
        post.viewCount = 0;
        return post;
    }

    public void changeTitle(String newTitle) {
        validateTitle(newTitle);
        this.title = newTitle;
    }

    public void validateOwnership(User user) {
        if (!this.author.equals(user)) {
            throw new UnauthorizedException();
        }
    }

    private static void validateTitle(String title) {
        if (title.length() > 100) {
            throw new IllegalArgumentException("제목 길이 초과");
        }
    }
}
```

Service 역할 변경:
```java
@Service
public class PostService {
    // 오케스트레이터 역할만 수행
    public PostResponse createPost(User user, CreatePostRequest request) {
        Post post = Post.create(user, request.getTitle(), request.getContent());
        postRepository.save(post);
        return PostResponse.from(post);
    }
}
```

기대 효과:
- 응집도 향상: 도메인 관련 로직이 Entity로 모여 관리 용이
- 재사용성 증가: `post.delete()` 같은 메서드를 다른 서비스에서도 안전하게 재사용 가능
- 테스트 용이성: Entity 단위 테스트만으로 핵심 비즈니스 로직 검증 가능

<br/>
<br/>


### 3. 다시 한번 고민한 결과

Rich Domain Model로 리팩토링을 검토했지만, 현재 프로젝트 특성상 **오버엔지니어링**이라고 판단. 현재의 Anemic Domain Model(Transaction Script 패턴)이 가장 적합함.

**현재 설계가 적합한 이유**

1. **프로젝트의 단순성**
   - 복잡한 도메인 규칙이 없는 단순 CRUD 중심 커뮤니티 플랫폼
   - Rich Domain Model은 오버엔지니어링일 수 있음

2. **명확성과 유지보수**
   - Service 메서드 하나에 비즈니스 로직 전체가 순차적으로 명시
   - 흐름 파악이 쉽고 디버깅이 간단
   - 요구사항 변경 시 해당 Service 메서드만 수정 → 영향도 파악 용이

3. **Spring 표준 아키텍처**
   - Controller-Service-Repository로 이어지는 Spring Layered Architecture와 완벽히 일치

<br/>
<br/>
**Rich Domain Model이 필요한 시점**

현재는 아니지만, 다음 신호가 나타나면 점진적 전환 고려:

| 신호 | 기준 | 예시 |
|------|------|------|
| 1 | Service 특정 메서드 비대화 | 200줄 이상 |
| 2 | 검증 로직 중복 | 동일 로직이 3개 이상 Service에서 반복 |
| 3 | 복잡한 상태 전이 | State Machine 필요 (`DRAFT` → `REVIEWING` → `PUBLISHED`) |

**프로젝트 적용 원칙**

현재 상태:
- ✅ Anemic Domain Model (Transaction Script 패턴)
- Service가 많은 일을 하는 것 = 현재 프로젝트 규모와 요구사항에 맞춘 의도된 설계
- 실용적이고 효율적인 선택

향후 전환 필요 시:
- 위 3가지 신호 중 2개 이상 발생 → Rich Domain Model 리팩토링 검토
- 점진적 전환 (핵심 도메인부터)
- 기존 코드와의 공존 가능 (하이브리드 접근)